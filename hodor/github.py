"""GitHub helper utilities for Hodor."""

from __future__ import annotations

import json
import logging
import os
import subprocess
from typing import Any


logger = logging.getLogger(__name__)


class GitHubAPIError(RuntimeError):
    """Raised when gh fails or returns invalid data."""


def _run_gh_json_command(args: list[str], *, env: dict[str, str] | None = None) -> dict[str, Any]:
    try:
        result = subprocess.run(
            args,
            check=True,
            capture_output=True,
            text=True,
            env=env,
        )
    except subprocess.CalledProcessError as exc:  # pragma: no cover - passthrough path
        error_msg = exc.stderr if getattr(exc, "stderr", None) else str(exc)
        raise GitHubAPIError(error_msg) from exc

    output = result.stdout.strip()
    try:
        return json.loads(output)
    except json.JSONDecodeError as exc:  # pragma: no cover - passthrough path
        raise GitHubAPIError(f"Unable to parse gh JSON output: {exc}") from exc


def fetch_github_pr_info(
    owner: str,
    repo: str,
    pr_number: str | int,
) -> dict[str, Any]:
    fields = [
        "number",
        "title",
        "body",
        "author",
        "baseRefName",
        "headRefName",
        "baseRefOid",
        "headRefOid",
        "changedFiles",
        "labels",
        "comments",
        "state",
        "isDraft",
        "createdAt",
        "updatedAt",
        "mergeable",
        "url",
    ]
    repo_full_path = f"{owner}/{repo}"
    args = [
        "gh",
        "pr",
        "view",
        str(pr_number),
        "-R",
        repo_full_path,
        "--json",
        ",".join(fields),
    ]
    return _run_gh_json_command(args)


def normalize_github_metadata(raw: dict[str, Any]) -> dict[str, Any]:
    metadata = {
        "title": raw.get("title"),
        "description": raw.get("body", ""),
        "source_branch": raw.get("headRefName"),
        "target_branch": raw.get("baseRefName"),
        "changes_count": raw.get("changedFiles"),
        "labels": [{"name": lbl.get("name") or lbl.get("id")} for lbl in (raw.get("labels") or [])],
        "author": {
            "username": raw.get("author", {}).get("login") or raw.get("author", {}).get("name"),
            "name": raw.get("author", {}).get("name"),
        },
        "Notes": _github_comments_to_notes(raw.get("comments")),
    }
    return metadata


def find_hodor_comment_github(
    owner: str,
    repo: str,
    pr_number: str | int,
) -> dict[str, Any] | None:
    """Find the existing Hodor review comment on a GitHub PR."""

    try:
        result = subprocess.run(
            [
                "gh", "api",
                f"repos/{owner}/{repo}/issues/{pr_number}/comments",
                "--paginate",
                "--jq",
                '.[] | select(.body | contains("Review generated by Hodor")) | {id, body}',
            ],
            capture_output=True,
            text=True,
        )
    except Exception as exc:
        logger.warning(f"Failed to search for existing Hodor comment: {exc}")
        return None

    if result.returncode != 0 or not result.stdout.strip():
        return None

    lines = [line for line in result.stdout.strip().split("\n") if line.strip()]
    if not lines:
        return None

    try:
        return json.loads(lines[-1])
    except json.JSONDecodeError:
        logger.warning("Failed to parse Hodor comment JSON from gh api output")
        return None


def update_github_pr_comment(
    owner: str,
    repo: str,
    comment_id: int,
    body: str,
) -> None:
    """Update an existing comment on a GitHub PR."""

    subprocess.run(
        [
            "gh", "api", "--method", "PATCH",
            f"repos/{owner}/{repo}/issues/comments/{comment_id}",
            "-f", f"body={body}",
        ],
        check=True,
        capture_output=True,
        text=True,
    )


def create_github_pr_comment(
    owner: str,
    repo: str,
    pr_number: str | int,
    body: str,
) -> None:
    """Create a new issue comment on a GitHub PR."""

    subprocess.run(
        [
            "gh", "api", "--method", "POST",
            f"repos/{owner}/{repo}/issues/{pr_number}/comments",
            "-f", f"body={body}",
        ],
        check=True,
        capture_output=True,
        text=True,
    )


def _github_comments_to_notes(
    comments: dict[str, Any] | list[dict[str, Any]] | None,
) -> list[dict[str, Any]]:
    if not comments:
        return []

    if isinstance(comments, list):
        nodes = comments
    elif isinstance(comments, dict):
        nodes = comments.get("nodes") or comments.get("edges") or []
        # Handle GraphQL edge format
        if nodes and isinstance(nodes[0], dict) and "node" in nodes[0]:
            nodes = [edge.get("node", {}) for edge in nodes]
    else:
        nodes = []
    notes: list[dict[str, Any]] = []
    for node in nodes:
        notes.append(
            {
                "body": node.get("body", ""),
                "author": {
                    "username": node.get("author", {}).get("login") or node.get("author", {}).get("name"),
                    "name": node.get("author", {}).get("name"),
                },
                "created_at": node.get("createdAt"),
            }
        )
    return notes
